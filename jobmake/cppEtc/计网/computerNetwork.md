# 计网面经

### 1. OSI 七层模型

自底向上分别是：

1. 物理层：传输基本单位是比特，主要负责透明比特流的传输。
2. 数据链路层：传输基本单位是帧。把比特封装成帧，通过差错控制，把有差错的物理链路变为无差错的数据链路。
3. 网络层：传输基本单位是包。在网络层通过路由算法，为数据包的传输选择合适的路径，主要功能有流量控制，拥塞控制，路由选择。
4. 传输层：数据传输基本单元是报文，向下屏蔽具体的通信过程，实现端到端的通信，保证数据的可靠传输。
5. 会话层：负责建立、维护、终止会话。
6. 表示层：负责数据的格式化，加密解密，压缩解压缩
7. 应用层：负责应用程序的数据交互，比如发送邮件，传文件视频什么的。

### 2. TCP/IP 四层模型

从下到上分别是：

1. 主机-网络层：物理层 + 数据链路层
2. 互联网络层：网络层
3. 传输层：传输层
4. 应用层：应用层 + 表示层 + 会话层

七层模型是一个理论模型，而四层模型是一个实际模型，实际应用中更多的是四层模型。

### 3. TCP/IP 协议族

主要包含内容：

1. 应用层

   1. HTTP：超文本传输协议：万维网和本地浏览器之间的传输协议
   2. FTP：文件传输协议：用于文件的上传和下载
   3. SMTP：简单邮件传输协议：用于发送邮件
   4. DNS：域名系统：一个超级大的哈希表，用于域名和 IP 地址的映射
   5. Telnet：远程登录协议：是用户在本地计算机上登录远程计算机的标准协议
   6. OSPF：开放最短路径优先协议：动态路由更新协议，用于路由器之间的通信
2. 传输层

   1. TCP：传输控制协议：面向连接的、可靠的、基于字节流的传输层通信协议
   2. UDP：用户数据报协议：无连接的、不可靠的、基于数据报的传输层通信协议
3. 网络层

   1. IP：网际协议：定义了计算机在网络上的地址和路由的协议
   2. ICMP：Internet 控制消息协议：用于在 IP 网络上发送控制消息
4. 数据链路层

   1. ARP：地址解析协议：用于将 IP 地址解析为 MAC 地址
   2. RARP：逆地址解析协议：用于将 MAC 地址解析为 IP 地址

### 4. 说一下一次完整的 HTTP 请求过程

1. 域名解析：浏览器通过 DNS 解析域名得到 IP 地址
2. 建立连接：通过三次握手，浏览器和服务器建立连接
3. 发起 http 请求：浏览器向服务器发送请求
4. 服务器响应请求：服务器处理请求，返回 html 代码
5. 浏览器解析 html 代码：浏览器解析 html 代码，请求 html 代码中的资源（js、css、图片等）
6. 浏览器渲染页面：浏览器根据 html 代码和资源渲染页面

### 5. DNS

Domain Name System: 域名系统，用于域名和 IP 地址的映射的一个分布式数据库。作用是把域名映射成 IP 地址，这个过程叫做域名解析，是一个应用层协议，使用 UDP 协议。

1. 域名解析过程

mail.cctv.com 从左至右：三级域名、二级域名、顶级域名

1. 浏览器缓存：本地电脑检查浏览器缓存里面有没有这个域名对应的 IP 地址。
2. 系统缓存：如果浏览器缓存里面没有，就会检查系统缓存里面有没有这个域名对应的 IP 地址。
3. 本地 DNS 服务器：一般一个完整的内网都有一个本地 DNS 服务器。本地计算机把域名发送给本地 DNS 服务器，本地 DNS 服务器会先检查自己的缓存，如果有就直接返回 IP 地址。

本地不太行了，要去求助根域名服务器了。这里由本地 DNS 服务器代替本地计算机向根域名服务器发送请求。

1. 根域名服务器：根域名服务器知道所有顶级域名服务器的 IP 地址，返回顶级域名服务器的 IP 地址，告诉你要去哪个顶级域名服务器找 IP 地址。
2. 顶级域名服务器：顶级域名服务器管理自己范围内的所有二级域名。
3. nameServer：要么直接存储需要的 IP 地址，要么存储下一级域名服务器的 IP 地址。
4. 递归查询和迭代查询

   1. 递归查询：本地 DNS 服务器向根域名服务器发起请求，根域名服务器返回给本地 DNS 服务器，本地 DNS 服务器再返回给本地计算机。
   2. 迭代查询：本地 DNS 服务器向根域名服务器发起请求，根域名服务器返回给本地 DNS 服务器，本地 DNS 服务器再向顶级域名服务器发起请求，顶级域名服务器返回给本地 DNS 服务器，本地 DNS 服务器再向二级域名服务器发起请求，二级域名服务器返回给本地 DNS 服务器，本地 DNS 服务器再返回给本地计算机。
5. 为什么本地 DNS 向根域名服务器的查询使用迭代查询？

根域名服务器是全球只有 13 台，如果全球每个人都使用递归查询，根域名服务器的压力会非常大。

### 6. 为什么域名解析使用 UDP 协议？

UDP 协议是无连接的，不需要建立连接，速度快。

### 7. 为什么区域传送使用 TCP 协议？

什么是区域传送？区域传送是指 DNS 服务器之间的数据同步。

1. 区域传送是 DNS 服务器之间的数据同步，需要精准可靠，所以使用 TCP 协议。
2. 区域传送的数据量比较大，UDP 传输的内容不能超过 512 字节，所以使用 TCP 协议。

### 8. HTTP 长连接和短连接

1. 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。HTTP/1.0 默认使用短连接。
2. 长连接：客户端和服务器建立一次连接，可以进行多次 HTTP 操作，任务结束不中断连接。HTTP/1.1 默认使用长连接。

### 9. TCP 粘包和拆包

粘包：发送方把多个数据表封装成一个数据包发送

拆包：发送方把一个数据包拆分成多个数据包发送

为什么会发生粘包和拆包？

TCP 是流传输，没有大小限制，发送方会设置一个缓冲区进行优化。如果一次请求数据量很少，缓冲区装不满，就会把多个请求数据封装成一个数据包发送，这就是粘包。如果一次请求数据量很大，缓冲区装不下，就会把一个请求数据拆分成多个数据包发送，这就是拆包。

解决办法：

固定包的长度；在包头加上包的长度；在包尾加上分隔符之类的。

### 10. HTTP 的请求方法

HTTP1.0：GET、POST、HEAD

HTTP1.1：OPTIONS、PUT、DELETE、TRACE、CONNECT、PATCH

1. GET：请求指定的页面信息，并返回实体主体。
2. HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。
3. POST：向指定资源提交数据进行处理请求，数据包含在请求体中。
4. PUT：从客户端向服务器传送的数据取代指定的文档的内容。
5. DELETE：请求服务器删除指定的页面。
6. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7. OPTIONS：允许客户端查看服务器的性能。
8. TRACE：回显服务器收到的请求，主要用于测试或诊断。
9. PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新。

- get 和 post 的区别：

1. get 是获取数据，post 是修改数据。
2. get 请求的数据会附在 URL 后面，以?分割 URL 和传输数据，参数之间以&相连，post 请求的数据放在请求体中。
3. get 请求的数据长度有限制，post 请求的数据长度没有限制。
4. get 产生一个 TCP 数据包
5. get 请求会被浏览器主动缓存，post 不会，除非手动设置。
6. get 请求是幂等的，post 请求不是幂等的。

### 11. 一个 TCP 连接可以同时发送多个 HTTP 请求吗？

可以，HTTP1.1 默认使用长连接，一个 TCP 连接可以发送多个 HTTP 请求。但是不能同时发送，只能一个一个发送。时分复用。

### 12. 浏览器对同一 Host 建立的 TCP 连接数量有限制吗？

有限制，不同浏览器有不同的限制，一般是 6 个。

### 13. 在浏览器中输入 URL 到页面显示的过程

1. 浏览器缓存：浏览器检查缓存，如果有缓存，直接显示。
2. 如果没有缓存，域名解析，找到域名对应的 IP 地址。
3. TCP 连接，三次握手。
4. 发送 HTTP 请求。
5. 服务器响应，返回 html 代码。
6. 浏览器解析 html 代码，请求 html 代码中的资源。
7. 服务器返回资源。
8. 浏览器渲染页面。

### 14. DNS 负载均衡

在 DNS 服务器中为同一个主机名配置多个 IP 地址，当 DNS 服务器收到请求时，会根据负载均衡算法返回其中一个 IP 地址，实现负载均衡。

### 15. HTTP 和 HTTPS 的区别

1. HTTP 是超文本传输协议，明文传输，不安全；HTTPS 是在 HTTP 的基础上加入 SSL 层，加密传输，安全。
2. HTTP 和 HTTPS 使用的端口不一样，HTTP 使用 80 端口，HTTPS 使用 443 端口。

### 16. SSL/TLS 协议

SSL（Secure Sockets Layer）安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通信提供安全支持。

TLS（Transport Layer Security）传输层安全协议，是 SSL 协议的继任者，是一个独立于应用层协议的安全协议。

SSL/TLS 协议的基本原理：

1. 服务器端和客户端建立安全连接，交换密钥。
2. 服务器端和客户端使用密钥加密解密数据。
3. 服务器端和客户端验证对方身份。

### 17. TCP 连接建立：三次握手和四次挥手

名词解释：

SYN：全称 synchronize，同步序列编号；

client_isn：客户端的初始序列号；全称 initial sequence number；

1. 三次握手过程
   1. 第一次握手：客户端向服务端发送一个不包含数据的报文段，其中包含 SYN 比特，设置为 1，同时客户端选择一个初始序列号 client_isn，用来标识从客户端到服务端的数据。此时客户端进入 SYN_SENT 状态。
   2. 第二次握手：服务端收到客户端的 SYN 报文段后，在服务端为这个连接分配 TCP 缓存和变量，然后向客户端发送一个不包含数据的报文段，其中包含 SYN 比特和 ACK 比特，设置为 1，同时服务端选择一个初始序列号 server_isn
   3. 第三次握手：客户端收到服务端的 SYN 和 ACK 报文段后，在客户端为这个连接分配 TCP 缓存和变量，然后发送给服务端：SYN=0，ack = server_ins + 1, seq = client_isn + 1。这个报文段可以包含应用层的数据。

我的理解

三次握手的过程实际上就是客户端和服务器互相确认对方是否具有接收数据和发送数据能力的过程。在第一次握手之后，服务器确认了客户端的发送数据能力，在第二次握手之后，客户端确认了服务器具有接收和发送数据的能力，所以在第三次握手的时候，客户端就可以直接在这次握手的过程中包含应用层的数据了。在第三次握手之后，服务器就确认了客户端具有发送数据的能力了。

1. 为什么是三次握手而不是两次握手？

因为如果某些失效或者延迟的连接请求在连接结束之后到达服务器端，那服务器会认为这个客户端又要建立连接，它就会回一个确认连接的报文段，然后预留资源，但是客户端并不会回应，就造成资源的浪费了。

1. 四次挥手过程

谁都可以开始执行挥手过程，以下是客户端开始挥手的过程：

1. 为什么是四次挥手？

因为 TCP 是全双工的，客户端和服务端都可以发送数据，所以在关闭连接的时候，需要客户端和服务端都发送一个 FIN 报文段，表示不再发送数据了。比如客户端没有数据要发送了，于是进行第一次挥手，服务端收到 FIN 报文段之后，回复 ACK 报文段，但是这个时候服务端可能还有数据要发送，所以服务端在发送完数据之后，再发送一个 FIN 报文段，表示服务端不再发送数据了。所以挥手是四次。

1. 为什么要等 2MSL?

   1. 最后一个 ACK 可能丢失，服务端会重新发送 FIN 报文段，如果客户端直接关了，就不会回 ACK 了，然后服务端就一直等了。
   2. 保证连接中不存在正在传输的数据，否则下一次连接可能收到上一次连接遗留在网络中的数据。
   3. 为什么是 2MSL，而不是 1MSL？因为客户端回了 ACK 之后，如果在一个最大来回时间内，即 2MSL 内，没有收到服务端重传的 FIN 报文段，就说明服务端已经成功收到了 ACK 报文段，所以客户端就可以放心关闭了。
2. SYN 泛洪攻击

攻击者发送大量的 SYN 报文段，但是不完成第三次握手的过程。由于服务器在收到 SYN 报文段之后就会为这一个 TCP 连接分配资源，所以攻击者可以通过这种方式耗尽服务器的资源。

解决办法：

（1）缩短 SYN timeout 时间

（2）SYN cookies：服务器在收到 SYN 报文段之后，不会为这个 TCP 连接分配资源，而是把客户端的 client_isn 和 server_isn 的一些信息加密后发送给客户端，客户端在第三次握手的时候，把这个信息发送给服务器，服务器根据这个信息来判断这个连接是否合法。

### 18. TCP 拥塞控制

sstresh: slow start threshold，慢启动阈值

cwnd: congestion window，拥塞窗口

MSS: Maximum Segment Size，最大报文段长度

#### 1. 慢启动

慢启动是 TCP 拥塞控制的一种算法，用来控制发送方的发送速率。慢启动的过程如下：

1. 初始时，cwnd = 1MSS，发送一个报文段。
2. 每收到一个 ACK 报文段，cwnd + 1MSS
3. 每经过一个 RTT，cwnd * 2
4. 直到 cwnd >= sstresh，进入拥塞避免阶段。

#### 2. 拥塞避免

拥塞避免是 TCP 拥塞控制的一种算法，用来控制发送方的发送速率。拥塞避免的过程如下：

1. 每收到一个 ACK 报文段，cwnd = cwnd + 1 / cwnd
2. 每经过一个 RTT，cwnd + 1
3. 直到 cwnd >= sstresh，进入快速恢复阶段。
